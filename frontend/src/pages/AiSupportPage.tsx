import { useEffect, useState } from "react";
import { apiRequest } from "../api/client";
import { getRole } from "../auth";

type AiRequestLog = {
  id: number;
  userId: number;
  userName?: string | null;
  userEmail?: string | null;
  modelName: string;
  requestText: string;
  responseText: string;
  latencyMs: number;
  status: string;
  createdAt?: string | null;
};

type WatchedLesson = {
  lessonId: number;
  courseId: number;
  courseTitle: string;
  lessonTitle: string;
  lessonContent: string | null;
  progressPercent: number;
};

type QuizQuestion = {
  id: number;
  type: "mcq" | "short";
  question: string;
  choices?: string[] | null;
  answerIndex?: number | null;
  answerText?: string | null;
  explanation?: string | null;
};

type QuizAnswer = {
  choiceIndex?: number;
  text?: string;
};

const normalizeAnswer = (value: string) => value.trim().toLowerCase().replace(/\s+/g, " ");

const parseQuizOutput = (output: string): QuizQuestion[] | null => {
  let text = output.trim();
  if (!text) return null;
  if (text.startsWith("```")) {
    text = text.replace(/^```[a-z]*\n?/i, "").replace(/```$/i, "");
  }
  const first = text.indexOf("{");
  const last = text.lastIndexOf("}");
  if (first >= 0 && last >= 0) {
    text = text.slice(first, last + 1);
  }
  try {
    const data = JSON.parse(text);
    if (data && Array.isArray(data.questions)) {
      return data.questions as QuizQuestion[];
    }
  } catch {
    return null;
  }
  return null;
};

const pickDefaultLesson = (lessons: WatchedLesson[]) => {
  return lessons.reduce((best, current) => {
    if (!best) return current;
    if (current.progressPercent > best.progressPercent) return current;
    if (current.progressPercent === best.progressPercent && current.lessonId > best.lessonId) {
      return current;
    }
    return best;
  }, lessons[0]);
};

export default function AiSupportPage() {
  const role = getRole();
  const [aiInput, setAiInput] = useState("");
  const [summaryOutput, setSummaryOutput] = useState("");
  const [quizRaw, setQuizRaw] = useState("");
  const [quizData, setQuizData] = useState<QuizQuestion[] | null>(null);
  const [quizLoading, setQuizLoading] = useState(false);
  const [quizError, setQuizError] = useState<string | null>(null);
  const [answers, setAnswers] = useState<Record<number, QuizAnswer>>({});
  const [submitted, setSubmitted] = useState(false);
  const [score, setScore] = useState<{ correct: number; total: number } | null>(null);
  const [wrongIds, setWrongIds] = useState<number[]>([]);
  const [requests, setRequests] = useState<AiRequestLog[]>([]);
  const [watchedLessons, setWatchedLessons] = useState<WatchedLesson[]>([]);
  const [selectedLessonId, setSelectedLessonId] = useState("");
  const [autoGenerated, setAutoGenerated] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadRequests = () => {
    if (!role) {
      return;
    }
    apiRequest<AiRequestLog[]>("/api/ai/requests")
      .then((data) => {
        setRequests(data);
        setError(null);
      })
      .catch((err) => setError((err as Error).message));
  };

  const loadWatchedLessons = () => {
    if (!role) {
      return;
    }
    apiRequest<WatchedLesson[]>("/api/lessons/watched")
      .then((data) => {
        setWatchedLessons(data);
        setError(null);
      })
      .catch((err) => setError((err as Error).message));
  };

  const resetQuizState = () => {
    setAnswers({});
    setSubmitted(false);
    setScore(null);
    setWrongIds([]);
  };

  const generateSummary = async () => {
    if (!aiInput.trim()) {
      setError("요약할 텍스트가 없습니다.");
      return;
    }
    try {
      const data = await apiRequest<{ output: string }>("/api/ai/summary", {
        method: "POST",
        body: JSON.stringify({ text: aiInput }),
      });
      setSummaryOutput(data.output);
      setError(null);
      loadRequests();
    } catch (err) {
      setError((err as Error).message);
    }
  };

  const generateQuiz = async (inputOverride?: string) => {
    const text = (inputOverride ?? aiInput).trim();
    if (!text) {
      setQuizError("퀴즈를 생성할 텍스트가 없습니다.");
      return;
    }
    setQuizLoading(true);
    setQuizError(null);
    setQuizRaw("");
    setQuizData(null);
    resetQuizState();
    try {
      const data = await apiRequest<{ output: string }>("/api/ai/quiz", {
        method: "POST",
        body: JSON.stringify({ text }),
      });
      const output = data.output || "";
      setQuizRaw(output);
      const parsed = parseQuizOutput(output);
      if (!parsed || parsed.length === 0) {
        setQuizError("퀴즈 파싱에 실패했습니다.");
      } else {
        setQuizData(parsed);
      }
      loadRequests();
    } catch (err) {
      setQuizError((err as Error).message);
    } finally {
      setQuizLoading(false);
    }
  };

  const handleLessonChange = (lessonId: string, shouldGenerate = true) => {
    setSelectedLessonId(lessonId);
    const selected = watchedLessons.find((lesson) => lesson.lessonId === Number(lessonId));
    if (!selected) {
      return;
    }
    if (!selected.lessonContent) {
      setAiInput("");
      setQuizData(null);
      setQuizError("선택한 레슨에 콘텐츠가 없습니다.");
      return;
    }
    setAiInput(selected.lessonContent);
    setError(null);
    if (shouldGenerate) {
      void generateQuiz(selected.lessonContent);
    }
  };

  const updateAnswer = (questionId: number, answer: QuizAnswer) => {
    setAnswers((prev) => ({
      ...prev,
      [questionId]: { ...prev[questionId], ...answer },
    }));
  };

  const gradeQuiz = () => {
    if (!quizData) {
      return;
    }
    let correct = 0;
    const wrong: number[] = [];
    quizData.forEach((question) => {
      if (question.type === "mcq") {
        const selected = answers[question.id]?.choiceIndex;
        if (selected != null && question.answerIndex != null && selected === question.answerIndex) {
          correct += 1;
        } else {
          wrong.push(question.id);
        }
        return;
      }
      const userText = answers[question.id]?.text ?? "";
      const answerText = question.answerText ?? "";
      const normalizedUser = normalizeAnswer(userText);
      const normalizedAnswer = normalizeAnswer(answerText);
      const isCorrect =
        normalizedUser.length > 0 &&
        normalizedAnswer.length > 0 &&
        (normalizedUser === normalizedAnswer || normalizedUser.includes(normalizedAnswer));
      if (isCorrect) {
        correct += 1;
      } else {
        wrong.push(question.id);
      }
    });
    setScore({ correct, total: quizData.length });
    setWrongIds(wrong);
    setSubmitted(true);
  };

  const resetQuiz = () => {
    resetQuizState();
    setQuizError(null);
  };

  const toTypeLabel = (text: string) => {
    if (text.startsWith("summary:")) return "Summary";
    if (text.startsWith("quiz:")) return "Quiz";
    return "Request";
  };

  const trimPrompt = (text: string) => {
    const split = text.split(":\n\n");
    return split.length > 1 ? split.slice(1).join(":\n\n") : text;
  };

  useEffect(() => {
    loadRequests();
    loadWatchedLessons();
  }, [role]);

  useEffect(() => {
    if (!role || autoGenerated || selectedLessonId || watchedLessons.length === 0) {
      return;
    }
    const pick = pickDefaultLesson(watchedLessons);
    setAutoGenerated(true);
    handleLessonChange(String(pick.lessonId), true);
  }, [role, watchedLessons, selectedLessonId, autoGenerated]);

  const selectedLesson =
    selectedLessonId === ""
      ? null
      : watchedLessons.find((lesson) => lesson.lessonId === Number(selectedLessonId)) || null;

  return (
    <main className="page">
      <div className="page-header">
        <h1>AI Support · 요약 &amp; 퀴즈</h1>
        <p className="muted">
          OpenAI 기반으로 학습 내용을 요약하고 퀴즈를 생성하는 지원 영역입니다.
        </p>
      </div>

      {error && <p className="error">{error}</p>}

      <section className="card">
        <h2>요약 &amp; 퀴즈 생성</h2>
        <div className="form-grid">
          <label>
            시청한 레슨 선택
            <select value={selectedLessonId} onChange={(e) => handleLessonChange(e.target.value)}>
              <option value="">선택하세요</option>
              {watchedLessons.map((lesson) => (
                <option key={lesson.lessonId} value={lesson.lessonId}>
                  {lesson.courseTitle} · {lesson.lessonTitle} ({Math.round(lesson.progressPercent)}%)
                </option>
              ))}
            </select>
          </label>
          {selectedLesson && (
            <p className="muted">선택 즉시 15문항 퀴즈가 자동 생성됩니다.</p>
          )}
          <label>
            Input Text
            <textarea
              value={aiInput}
              onChange={(e) => setAiInput(e.target.value)}
              rows={4}
            />
          </label>
          <div className="form-actions">
            <button className="btn btn-primary" type="button" onClick={generateSummary}>
              요약 생성
            </button>
            <button className="btn" type="button" onClick={() => generateQuiz()}>
              퀴즈 다시 생성
            </button>
          </div>
        </div>
        {summaryOutput && (
          <div className="section">
            <h3>Summary</h3>
            <pre>{summaryOutput}</pre>
          </div>
        )}
      </section>

      <section className="card section">
        <h2>퀴즈</h2>
        {quizLoading && <p className="muted">퀴즈 생성 중...</p>}
        {quizError && <p className="error">{quizError}</p>}
        {!quizLoading && quizData && quizData.length > 0 ? (
          <div className="section">
            <ol className="card-grid">
              {quizData.map((question, index) => (
                <li key={question.id}>
                  <strong>
                    Q{index + 1}. {question.question}
                  </strong>
                  {question.type === "mcq" ? (
                    <div className="section">
                      {(question.choices || []).map((choice, choiceIndex) => (
                        <label key={choiceIndex}>
                          <input
                            type="radio"
                            name={`q-${question.id}`}
                            value={choiceIndex}
                            checked={answers[question.id]?.choiceIndex === choiceIndex}
                            onChange={() => updateAnswer(question.id, { choiceIndex })}
                            disabled={submitted}
                          />
                          {choice}
                        </label>
                      ))}
                    </div>
                  ) : (
                    <input
                      type="text"
                      value={answers[question.id]?.text ?? ""}
                      onChange={(e) => updateAnswer(question.id, { text: e.target.value })}
                      disabled={submitted}
                    />
                  )}
                </li>
              ))}
            </ol>
            <div className="form-actions">
              <button className="btn btn-primary" type="button" onClick={gradeQuiz} disabled={submitted}>
                제출
              </button>
              <button className="btn" type="button" onClick={resetQuiz}>
                다시 풀기
              </button>
            </div>
          </div>
        ) : (
          !quizLoading && <p className="muted">표시할 퀴즈가 없습니다.</p>
        )}

        {submitted && score && (
          <div className="section">
            <h3>채점 결과</h3>
            <p className="muted">
              {score.total}문항 중 {score.correct}문항 정답
            </p>
          </div>
        )}

        {submitted && quizData && wrongIds.length > 0 && (
          <div className="section">
            <h3>틀린 문제</h3>
            <ul className="card-grid">
              {quizData
                .filter((question) => wrongIds.includes(question.id))
                .map((question) => (
                  <li key={`wrong-${question.id}`}>
                    <strong>{question.question}</strong>
                    <p className="muted">
                      정답: {question.type === "mcq"
                        ? (question.choices || [])[question.answerIndex ?? -1] || ""
                        : question.answerText || ""}
                    </p>
                    {question.explanation && <p className="muted">{question.explanation}</p>}
                  </li>
                ))}
            </ul>
          </div>
        )}

        {quizError && quizRaw && (
          <details className="section">
            <summary>퀴즈 원문 보기</summary>
            <pre>{quizRaw}</pre>
          </details>
        )}
      </section>

      <section className="section card">
        <h2>요약 &amp; 퀴즈 기록</h2>
        {requests.length === 0 && !error ? (
          <p className="muted">표시할 기록이 없습니다.</p>
        ) : (
          <ul className="card-grid">
            {requests.map((req) => (
              <li key={req.id}>
                <strong>{toTypeLabel(req.requestText)}</strong>
                {role === "ADMIN" && (
                  <p className="muted">
                    {req.userName || req.userEmail || `User ${req.userId}`}
                  </p>
                )}
                <p className="muted">{trimPrompt(req.requestText)}</p>
                <p className="muted">{req.responseText}</p>
              </li>
            ))}
          </ul>
        )}
      </section>
    </main>
  );
}
